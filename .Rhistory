Soil_characteristics[i,2]<-"I"
}else{
Soil_characteristics[i,2]<-"O"
}
Soil_characteristics<-Soil_characteristics2
Soil_characteristics[1,2]<-"I"
Soil_characteristics<-Soil_characteristics2
Soil_characteristics$Location<-as.character(Soil_characteristics$Location)
for(i in 1:length(Soil_characteristics$Location))if(Soil_characteristics[i,2]=="in"){
Soil_characteristics[i,2]<-"I"
}else{
Soil_characteristics[i,2]<-"O"
}
Soil_characteristics$Location<-as.factor(Soil_characteristics$Location)
names(Soil_characteristics)[1:2]<-c("pop","location")
View(Root_size)
Root_size$pop<-gsub("^([0-9]+)[I,O][A-Z]+.*","\\1",Root_size$indiv)
Root_size$location<-gsub("^[0-9]+([I,O])[A-Z]+.*","\\1",Root_size$indiv)
Root_size$species<-gsub("^[0-9]+[I,O]([A-Z]+).*","\\1",Root_size$indiv)
Root_size$location<-as.factor(Root_size$location)
Root_size$species<-as.factor(Root_size$species)
Root_size$pop<-as.factor(Root_size$pop)
fulldata <- merge(Soil_characteristics, ndatas, by=c("pop","location"))
# note i used the SCALED dataframe for the total histology
fulldata <- merge(fulldata, Root_size, by=c("pop","location"))
View(fulldata)
fulldata <- merge(Soil_characteristics, ndatas, by=c("pop","location"))
# note i used the SCALED dataframe for the total histology
fulldata <- merge(fulldata, Root_size, by="indiv")
# note i used the SCALED dataframe for the total histology
fulldata <- merge(fulldata, Root_size, by=c("indiv","location","pop","species")
fulldata <- merge(Soil_characteristics, ndatas, by=c("pop","location"))
fulldata <- merge(Soil_characteristics, ndatas, by=c("pop","location"))
# note i used the SCALED dataframe for the total histology
fulldata <- merge(fulldata, Root_size, by=c("indiv","location","pop","species"))
fulldata %>% transmute(mean_root=(sum(fulldata[,20:29])))
fulldata %>% transmute(mean_root=(sum(fulldata[,20:29]))) ->fulldata
fulldata <- merge(Soil_characteristics, ndatas, by=c("pop","location"))
# note i used the SCALED dataframe for the total histology
fulldata <- merge(fulldata, Root_size, by=c("indiv","location","pop","species"))
length(fulldata[,20:29])
fulldata$mean_rootsize<-(sum(fulldata[,20:29])/length(fulldata[,20:29]))
for(i in 1:length(fulldata$indiv)){
fulldata$mean_rootsize[i]<-(sum(fulldata[i,20:29])/length(fulldata[,20:29]))
}
fulldata<-fulldata[,-c(20:29)]
# model myc_lesion
mod1 <- glmer(binlesion ~ None.Myc * mean_rootsize * species + pH + Agg_stability + N_percent + C_percent + (1 | pop) + (1 | indiv) , data = fulldata,family = binomial(link = "logit"))
binlesion<-cbind(fulldata$None.Path,100-fulldata$None.Path)
binmycorr<-cbind(fulldata$None.Myc,100-fulldata$None.Myc)
binherbivory<-cbind(fulldata$None.Herb,100-fulldata$None.Herb)
# model myc
GLMMmyc_lesion <- glmer(binlesionF ~ species + (1 | pop) , data = ndatas,family = binomial(link = "logit"))
binlesionF<-cbind(fulldata$None.Path,100-fulldata$None.Path)
binmycorrF<-cbind(fulldata$None.Myc,100-fulldata$None.Myc)
# model myc_lesion
mod1 <- glmer(binlesionF ~ None.Myc * mean_rootsize * species + pH + Agg_stability + N_percent + C_percent + (1 | pop) + (1 | indiv) , data = fulldata,family = binomial(link = "logit"))
fulldata <- merge(Soil_characteristics, ndata, by=c("pop","location"))
# note i used the SCALED dataframe for the total histology
fulldata <- merge(fulldata, Root_size, by=c("indiv","location","pop","species"))
for(i in 1:length(fulldata$indiv)){
fulldata$mean_rootsize[i]<-(sum(fulldata[i,20:29])/length(fulldata[,20:29]))
}
fulldata<-fulldata[,-c(20:29)]
binlesionF<-cbind(fulldata$None.Path,100-fulldata$None.Path)
binmycorrF<-cbind(fulldata$None.Myc,100-fulldata$None.Myc)
binherbivoryF<-cbind(fulldata$None.Herb,100-fulldata$None.Herb)
# model myc_lesion
mod1 <- glmer(binlesionF ~ scaled(None.Myc)  * scaled(mean_rootsize) * species + scaled(pH) + scaled(Agg_stability) + scaled(N_percent) + scaled(C_percent) + (1 | pop) + (1 | indiv) , data = fulldata,family = binomial(link = "logit"))
# model myc_lesion
mod1 <- glmer(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop) + (1 | indiv) , data = fulldata,family = binomial(link = "logit"))
summary(mod1)
# model myc_lesion
mod1 <- glmer(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"))
# model myc_lesion
mod1 <- glmer(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"), nAGQ = 100)
# model myc_lesion
mod1 <- glmer(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"), nAGQ = 200)
# model myc_lesion
mod1 <- glmer(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"), nAGQ = 200)
# model myc_lesion
mod1 <- glmer(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"), nAGQ = 150)
# model myc_lesion
mod1 <- glmer(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"), nAGQ = 100)
# model myc_lesion
mod1 <- glmmADMB(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"))
library("glmmADMB", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
# model myc_lesion
mod1 <- glmmADMB(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"))
# model myc_lesion
mod1 <- glmmADMB(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"))
# model myc_lesion
mod1 <- glmm.admb(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = binomial(link = "logit"))
# model myc_lesion
mod1 <- glmm.admb(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = "binomial")
# model myc_lesion
mod1 <- glmmadmb(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = "binomial")
fulldata$pop<-as.factor(fulldata$pop)
# model myc_lesion
mod1 <- glmmadmb(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = "binomial")
summary(mod1)
dredge(mod1)
dredge(mod2)
# model myc
mod2 <- glmmadmb(binmycorrF ~ scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop) , data = fulldata,family = "binomial")
dredge(mod2)
str(mod2.dredge)
mod2.dredge <- dredge(mod2)
str(mod2.dredge)
mod2.dredgegood <- mod2.dredge[,mod2.dredge=>7]
mod2.dredgegood <- mod2.dredge[,mod2.dredge<=7]
mod2.dredgegood <- mod2.dredge[[,mod2.dredge<=7]]
mod2.dredgegood <- subset(mod2.dredge,mod2.dredge$delta<=7)
mod2.dredgegood
mod1.dredge <- dredge(mod1)
row.has.na <- apply(PlantLength, 1, function(x){any(is.na(x))})
sum(row.has.na)
PlantLength.filtered <- PlantLength[!row.has.na,]# Removed all the rows with NAs
car::qqp(PlantLength$Length_plant, "norm")
car::qqp(PlantLength$Length_plant, "norm")
shapiro.test(PlantLength$Length_plant)
par(mfrow = c(1,1))
descdist(PlantLength.filtered$Length_plant, discrete = FALSE, boot = 1000)
f1g <- fitdist(PlantLength.filtered$Length_plant, "lnorm")
f2g <- fitdist(PlantLength.filtered$Length_plant, "norm")
f3g <- fitdist(PlantLength.filtered$Length_plant, "gamma")
f4g <- fitdist(PlantLength.filtered$Length_plant, "weibull")
f1g$aic
f2g$aic
f3g$aic
f4g$aic
mod1<-lm(Length_plant~Location*Species, data=PlantLength.filtered)
bc<-boxcox(mod1, lambda = seq(-2, 2, 0.1))
lambda <- bc$x[which.max(bc$y)]
PlantLength.filtered <- cbind(PlantLength.filtered, ((PlantLength.filtered$Length_plant^lambda)-1)/lambda)
names(PlantLength.filtered)[5] <- "Yprime"
mod1BC <- lm(Yprime~Location*Species, data=PlantLength.filtered)
par(mfrow = c(2, 2))
plot(mod1BC)
# Multicolinearity?
car::vif(mod1BC)
sqrt(car::vif(mod1BC)) > 2
mod1<-lmer(log(Length_plant)~Location*Species+(1|Pop), data=PlantLength.filtered)
mod1<-lmer(log(Length_plant)~Location*Species+(1|pop), data=PlantLength.filtered)
View(PlantLength.filtered)
library(tidyverse)
library(lme4)
library(MASS)
library(MuMIn)
library(emmeans)
library(boot)
library(brms)
library(loo)
library(fitdistrplus)
library(mefa)
library(ggbiplot)
library(pvclust)
library(vegan)
library(ggbiplot)
library(factoextra)
row.has.na <- apply(PlantLength, 1, function(x){any(is.na(x))})
sum(row.has.na)
PlantLength.filtered <- PlantLength[!row.has.na,]# Removed all the rows with NAs
car::qqp(PlantLength$Length_plant, "norm")
shapiro.test(PlantLength$Length_plant)
par(mfrow = c(1,1))
descdist(PlantLength.filtered$Length_plant, discrete = FALSE, boot = 1000)
f1g <- fitdist(PlantLength.filtered$Length_plant, "lnorm")
f2g <- fitdist(PlantLength.filtered$Length_plant, "norm")
f3g <- fitdist(PlantLength.filtered$Length_plant, "gamma")
f4g <- fitdist(PlantLength.filtered$Length_plant, "weibull")
f1g$aic
f2g$aic
f3g$aic
f4g$aic
mod1<-lm(Length_plant~Location*Species, data=PlantLength.filtered)
bc<-boxcox(mod1, lambda = seq(-2, 2, 0.1))
lambda <- bc$x[which.max(bc$y)]
PlantLength.filtered <- cbind(PlantLength.filtered, ((PlantLength.filtered$Length_plant^lambda)-1)/lambda)
names(PlantLength.filtered)[5] <- "Yprime"
mod1BC <- lm(Yprime~Location*Species, data=PlantLength.filtered)
par(mfrow = c(2, 2))
plot(mod1BC)
sqrt(car::vif(mod1BC)) > 2
mod1<-lmer(log(Length_plant)~Location*Species+(1|Pop), data=PlantLength.filtered)
mod3<-lmer(log(Length_plant)~1+(1|Pop), data=PlantLength.filtered)
AICres <- model.sel(mod1,mod2,mod3)
r.squaredLR(mod1)
summary(mod1)
confint(mod1)
PlantLength.filtered <- as.factor(PlantLength.filtered$Pop)
PlantLength.filtered
row.has.na <- apply(PlantLength, 1, function(x){any(is.na(x))})
sum(row.has.na)
PlantLength.filtered <- PlantLength[!row.has.na,]# Removed all the rows with NAs
mod1<-lmer(log(Length_plant)~Location*Species+(1|Pop), data=PlantLength.filtered)
mod2<-lmer(log(Length_plant)~Location+(1|Pop), data=PlantLength.filtered)
mod3<-lmer(log(Length_plant)~1+(1|Pop), data=PlantLength.filtered)
mod1
mod2
mod3
AICres <- model.sel(mod1,mod2,mod3)
AICres
r.squaredLR(mod1)
summary(mod1)
confint(mod1)
# Multicolinearity?
car::vif(mod1BC)
sqrt(car::vif(mod1BC)) > 2
bc<-boxcox(mod1, lambda = seq(-2, 2, 0.1))
mod1<-lm(Length_plant~Location*Species, data=PlantLength.filtered)
bc<-boxcox(mod1, lambda = seq(-2, 2, 0.1))
lambda <- bc$x[which.max(bc$y)]
PlantLength.filtered <- cbind(PlantLength.filtered, ((PlantLength.filtered$Length_plant^lambda)-1)/lambda)
names(PlantLength.filtered)[5] <- "Yprime"
mod1BC <- lm(Yprime~Location*Species, data=PlantLength.filtered)
par(mfrow = c(2, 2))
plot(mod1BC)
names(PlantLength.filtered)[length(PlantLength.filtered)] <- "Yprime"
mod1BC <- lm(Yprime~Location*Species, data=PlantLength.filtered)
par(mfrow = c(2, 2))
plot(mod1BC)
row.has.na <- apply(PlantLength, 1, function(x){any(is.na(x))})
sum(row.has.na)
PlantLength.filtered <- PlantLength[!row.has.na,]# Removed all the rows with NAs
PlantLength.filtered$Pop <- as.factor(PlantLength.filtered$Pop)
car::qqp(PlantLength$Length_plant, "norm")
shapiro.test(PlantLength$Length_plant)
par(mfrow = c(1,1))
descdist(PlantLength.filtered$Length_plant, discrete = FALSE, boot = 1000)
f1g <- fitdist(PlantLength.filtered$Length_plant, "lnorm")
f2g <- fitdist(PlantLength.filtered$Length_plant, "norm")
f3g <- fitdist(PlantLength.filtered$Length_plant, "gamma")
f4g <- fitdist(PlantLength.filtered$Length_plant, "weibull")
# https://jonlefcheck.net/2012/10/24/nmds-tutorial-in-r/
# https://oliviarata.wordpress.com/2014/04/17/ordinations-in-ggplot2/
#Make a matrix with no row or column equal to 0 (do not enclude the env variable (GM COVERAGE))
M <- as.matrix(FloristicSurvey[1:198,4:55])
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
which( colSums(M)==0 )
which( rowSums(M)==0 )
#Now that you know which column must be taken out, redo the matrix but with the last column, then remove the rows and columns =0
#I did this because the previous method doesnt work with the characters in the GM_COVERAGE column.
M <- as.matrix(FloristicSurvey[1:198,4:56])
#Now that you know which column must be taken out, redo the matrix but with the last column, then remove the rows and columns =0
#I did this because the previous method doesnt work with the characters in the GM_COVERAGE column.
M <- as.matrix(FloristicSurvey[1:198,4:56])
View(FloristicSurvey)
dim(FloristicSurvey)
#Now that you know which column must be taken out, redo the matrix but with the last column, then remove the rows and columns =0
#I did this because the previous method doesnt work with the characters in the GM_COVERAGE column.
M <- as.matrix([1:198,4:55])
#Now that you know which column must be taken out, redo the matrix but with the last column, then remove the rows and columns =0
#I did this because the previous method doesnt work with the characters in the GM_COVERAGE column.
M <- as.matrix([1:198,4:55])
#Now that you know which column must be taken out, redo the matrix but with the last column, then remove the rows and columns =0
#I did this because the previous method doesnt work with the characters in the GM_COVERAGE column.
M <- as.matrix(FloristicSurvey[1:198,4:55])
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
M<-M[,-45]
M<-M[-130,]
M<-M[-133,]
M<-M[-132,]
# Now I'll make the env column a vector on its own, but the previous colde now allows it to be in the same order as the matrix im using for distances.
GM_coverage_df <- data.frame(M[,52])
View(M)
View(FloristicSurvey)
#Now that you know which column must be taken out, redo the matrix but with the last column, then remove the rows and columns =0
#I did this because the previous method doesnt work with the characters in the GM_COVERAGE column.
M <- as.matrix(FloristicSurvey[1:198,4:55])
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
# https://jonlefcheck.net/2012/10/24/nmds-tutorial-in-r/
# https://oliviarata.wordpress.com/2014/04/17/ordinations-in-ggplot2/
#Make a matrix with no row or column equal to 0 (do not enclude the env variable (GM COVERAGE))
FloristicSurvey$GM_Coverage_category<-cut(FloristicSurvey$GM_Coverage, c(-Inf,25,50,75,100), labels = c("Low", "Med_Low", "Med_High", "High"))
table(FloristicSurvey$GM_Coverage_category)
table(FloristicSurvey$GM_Coverage_category)
M <- as.matrix(FloristicSurvey[1:198,4:56])
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
which( colSums(M)==0 )
which( rowSums(M)==0 )
GM_coverage_df <- data.frame(M[,56])
GM_coverage_df <- data.frame(M[,53])
M<-M[,-53]
class(M) <- "numeric"
which( colSums(M)==0 )
which( rowSums(M)==0 )
M<-M[,-45]
M<-M[-c(130,133),]
which( colSums(M)==0 )
which( rowSums(M)==0 )
# with vegdist from Bray to seroeson: add binary = T
dist_FloristicSurvey <- vegdist(M, method = "bray", binary = T)
#The metaMDS analysis could have done the distance matrix internally but i would rather control it since i have presence/abscence
meta.nmds.FloristicSurvey2D <- metaMDS(dist_FloristicSurvey, k=2, trymax = 1000)
# https://jonlefcheck.net/2012/10/24/nmds-tutorial-in-r/
# https://oliviarata.wordpress.com/2014/04/17/ordinations-in-ggplot2/
#Make a matrix with no row or column equal to 0 (do not enclude the env variable (GM COVERAGE))
FloristicSurvey$GM_Coverage_category<-cut(FloristicSurvey$GM_Coverage, c(-Inf,25,50,75,100), labels = c("Low", "Med_Low", "Med_High", "High"))
table(FloristicSurvey$GM_Coverage_category)
M <- as.matrix(FloristicSurvey[1:198,4:56])
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
GM_coverage_df <- data.frame(M[,53])
M<-M[,-53]
class(M) <- "numeric"
which( colSums(M)==0 )
M<-M[,-45]
which( rowSums(M)==0 )
M<-M[-c(130,133),]
# with vegdist from Bray to seroeson: add binary = T
dist_FloristicSurvey <- vegdist(M, method = "bray", binary = T)
#The metaMDS analysis could have done the distance matrix internally but i would rather control it since i have presence/abscence
meta.nmds.FloristicSurvey2D <- metaMDS(dist_FloristicSurvey, k=2, trymax = 1000)
str(meta.nmds.FloristicSurvey2D)
stressplot(meta.nmds.FloristicSurvey2D)
# envfit for the 2D
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, perm = 999) #standard envfit
GM_coverage_df
# envfit for the 2D
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, perm = 999) #standard envfit
# envfit for the 2D
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, perm = 10) #standard envfit
# envfit for the 2D
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, perm = 999) #standard envfit
envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, perm = 999)
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, perm = 999) #standard envfit
meta.nmds.FloristicSurvey2D
length(GM_coverage_df)
GM_coverage_df
View(GM_coverage_df)
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, permutations =  = 999) #standard envfit
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, permutations = 999) #standard envfit
meta.nmds.FloristicSurvey2D
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, permutations = 999) #standard envfit
M<-M[-c(130,133),]
GM_coverage_df <- GM_coverage_df[-c(130,133),])
GM_coverage_df <- GM_coverage_df[-c(130,133),]
GM_coverage_df
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, permutations = 999) #standard envfit
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, perm = 999) #standard envfit
GM_coverage_df <- data.frame(M[,53])
M<-M[,-53]
# https://jonlefcheck.net/2012/10/24/nmds-tutorial-in-r/
# https://oliviarata.wordpress.com/2014/04/17/ordinations-in-ggplot2/
#Make a matrix with no row or column equal to 0 (do not enclude the env variable (GM COVERAGE))
FloristicSurvey$GM_Coverage_category<-cut(FloristicSurvey$GM_Coverage, c(-Inf,25,50,75,100), labels = c("Low", "Med_Low", "Med_High", "High"))
table(FloristicSurvey$GM_Coverage_category)
M <- as.matrix(FloristicSurvey[1:198,4:56])
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
GM_coverage_df <- data.frame(M[,53])
M<-M[,-53]
class(M) <- "numeric"
which( colSums(M)==0 )
M<-M[,-45]
# with vegdist from Bray to seroeson: add binary = T
dist_FloristicSurvey <- vegdist(M, method = "bray", binary = T)
#The metaMDS analysis could have done the distance matrix internally but i would rather control it since i have presence/abscence
meta.nmds.FloristicSurvey2D <- metaMDS(dist_FloristicSurvey, k=2, trymax = 1000)
#The metaMDS analysis could have done the distance matrix internally but i would rather control it since i have presence/abscence
meta.nmds.FloristicSurvey2D <- metaMDS(dist_FloristicSurvey, k=2, trymax = 1000)
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
GM_coverage_df <- data.frame(M[,53])
# https://jonlefcheck.net/2012/10/24/nmds-tutorial-in-r/
# https://oliviarata.wordpress.com/2014/04/17/ordinations-in-ggplot2/
#Make a matrix with no row or column equal to 0 (do not enclude the env variable (GM COVERAGE))
FloristicSurvey$GM_Coverage_category<-cut(FloristicSurvey$GM_Coverage, c(-Inf,25,50,75,100), labels = c("Low", "Med_Low", "Med_High", "High"))
table(FloristicSurvey$GM_Coverage_category)
M <- as.matrix(FloristicSurvey[1:198,4:56])
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
GM_coverage_df <- data.frame(M[,53])
M<-M[,-53]
class(M) <- "numeric"
which( colSums(M)==0 )
M<-M[,-45]
# with vegdist from Bray to seroeson: add binary = T
dist_FloristicSurvey <- vegdist(M, method = "bray", binary = T)
#The metaMDS analysis could have done the distance matrix internally but i would rather control it since i have presence/abscence
meta.nmds.FloristicSurvey2D <- metaMDS(dist_FloristicSurvey, k=2, trymax = 1000)
table(FloristicSurvey$GM_Coverage_category)
M <- as.matrix(FloristicSurvey[1:198,4:56])
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
M<-M[,-53]
class(M[,1:52]) <- "numeric"
which( colSums(M[,1:52])==0 )
which(colSums(M[,1:52])==0 )
M[,1:52]
which(colSums(as.numeric(M[,1:52]))==0 )
as.numeric(M[,1:52])
as.matrix(M[,1:52])
# https://jonlefcheck.net/2012/10/24/nmds-tutorial-in-r/
# https://oliviarata.wordpress.com/2014/04/17/ordinations-in-ggplot2/
#Make a matrix with no row or column equal to 0 (do not enclude the env variable (GM COVERAGE))
FloristicSurvey$GM_Coverage_category<-cut(FloristicSurvey$GM_Coverage, c(-Inf,25,50,75,100), labels = c("Low", "Med_Low", "Med_High", "High"))
table(FloristicSurvey$GM_Coverage_category)
M <- as.matrix(FloristicSurvey[1:198,4:56])
M[is.na(M)] <- 0
rownames(M) <- FloristicSurvey$Population
M<-M[-c(130,133),]
M<-M[,-45]
GM_coverage_df <- data.frame(M[,53])
length(M)
GM_coverage_df <- data.frame(M[,52])
M<-M[,-52]
# with vegdist from Bray to seroeson: add binary = T
dist_FloristicSurvey <- vegdist(M, method = "bray", binary = T)
class(M) <- "numeric"
# with vegdist from Bray to seroeson: add binary = T
dist_FloristicSurvey <- vegdist(M, method = "bray", binary = T)
#The metaMDS analysis could have done the distance matrix internally but i would rather control it since i have presence/abscence
meta.nmds.FloristicSurvey2D <- metaMDS(dist_FloristicSurvey, k=2, trymax = 1000)
str(meta.nmds.FloristicSurvey2D)
stressplot(meta.nmds.FloristicSurvey2D)
FloristicSurvey_envfit <- envfit(meta.nmds.FloristicSurvey2D, env = GM_coverage_df, perm = 999) #standard envfit
FloristicSurvey_envfit
#data for plotting
##NMDS points
FloristicSurvey.NMDS.data<-GM_coverage_df
FloristicSurvey.NMDS.data$NMDS1<-meta.nmds.FloristicSurvey2D$points[ ,1]
FloristicSurvey.NMDS.data$NMDS2<-meta.nmds.FloristicSurvey2D$points[ ,2]
colnames(FloristicSurvey.NMDS.data)[1] <- "GM_Coverage"
# data for the envfit arrows
env.scores.FloristicSurvey <- as.data.frame(scores(FloristicSurvey_envfit, display = "vectors")) #extracts relevant scores from envifit
env.scores.FloristicSurvey <- cbind(env.scores.FloristicSurvey, env.variables = rownames(env.scores.FloristicSurvey)) #and then gives them their names
# function for ellipsess - just run this, is used later
#taken from the excellent stackoverflow Q+A: http://stackoverflow.com/questions/13794419/plotting-ordiellipse-function-from-vegan-package-onto-nmds-plot-created-in-ggplo
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100)
{
theta <- (0:npoints) * 2 * pi/npoints
Circle <- cbind(cos(theta), sin(theta))
t(center + scale * t(Circle %*% chol(cov)))
}
#data for ellipse, use GM coverage
df_ell.FSurvey.GM_coverage <- data.frame() #sets up a data frame before running the function.
for(g in levels(FloristicSurvey.NMDS.data$GM_Coverage)){
df_ell.FSurvey.GM_coverage <- rbind(df_ell.FSurvey.GM_coverage, cbind(as.data.frame(with(FloristicSurvey.NMDS.data [FloristicSurvey.NMDS.data$GM_Coverage==g,],
veganCovEllipse(cov.wt(cbind(NMDS1,NMDS2),wt=rep(1/length(NMDS1),length(NMDS1)))$cov,center=c(mean(NMDS1),mean(NMDS2)))))
,GM_coverage=g))
}
# data for labelling the ellipse
NMDS.mean.FloristicSurvey=aggregate(FloristicSurvey.NMDS.data[ ,c("NMDS1", "NMDS2")],
list(group = FloristicSurvey.NMDS.data$GM_Coverage), mean)
## finally plotting.
mult <- 1 #multiplier for the arrows and text for envfit below. You can change this and then rerun the plot command.
ggplot(data = FloristicSurvey.NMDS.data, aes(y = NMDS2, x = NMDS1))+
geom_path(data = df_ell.FSurvey.GM_coverage, aes(x = NMDS1, y = NMDS2, group = df_ell.FSurvey.GM_coverage$GM_coverage, color=df_ell.FSurvey.GM_coverage$GM_coverage))+
geom_point( aes(color = FloristicSurvey.NMDS.data$GM_Coverage), size = 1)+
scale_color_manual(values = c(14,5,19,2))+
coord_cartesian(xlim = c(-1,1.5))+
theme_simple()+ guides(color=guide_legend("Garlic Mustard Coverage"))
Soil_characteristics$Location<-as.character(Soil_characteristics$Location)
Soil_characteristics$Location<-as.character(Soil_characteristics$Location)
Soil_characteristics
View(Soil_characteristics)
Soil_characteristics <- read.csv("CSV/Soil_characteristics.txt", sep="\t")
Soil_characteristics$Location<-as.character(Soil_characteristics$Location)
for(i in 1:length(Soil_characteristics$Location))if(Soil_characteristics[i,2]=="in"){
Soil_characteristics[i,2]<-"I"
}else{
Soil_characteristics[i,2]<-"O"
}
Soil_characteristics$Location<-as.factor(Soil_characteristics$Location)
names(Soil_characteristics)[1:2]<-c("pop","location")
fulldata <- merge(Soil_characteristics, ndata, by=c("pop","location"))
# note i used the SCALED dataframe for the total histology
fulldata <- merge(fulldata, Root_size, by=c("indiv","location","pop","species"))
for(i in 1:length(fulldata$indiv)){
fulldata$mean_rootsize[i]<-(sum(fulldata[i,20:29])/length(fulldata[,20:29]))
}
fulldata<-fulldata[,-c(20:29)]
binlesionF<-cbind(fulldata$None.Path,100-fulldata$None.Path)
binmycorrF<-cbind(fulldata$None.Myc,100-fulldata$None.Myc)
binherbivoryF<-cbind(fulldata$None.Herb,100-fulldata$None.Herb)
fulldata$pop<-as.factor(fulldata$pop)
# model myc_lesion
mod1 <- glmmadmb(binlesionF ~ scale(None.Myc)  * scale(mean_rootsize) * species + scale(pH) + scale(Agg_stability) + scale(N_percent) + scale(C_percent) + (1 | pop), data = fulldata,family = "binomial")
library("glmmADMB", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
prplot(mod2,1)
library(lme4)
library(MuMIn)
library(lmerTest)
library(tidyverse)
library(arm)
library(emmeans)
library(sjPlot)
library(car)
library(corrplot)
library(ridge)
library(multcomp)
library(psych)
library(pastecs)
library(faraway)
library(boot)
glm.diag(mod2)
glm.diag.plots(mod2)
mod1 <- lm(sr ~ pop15 + dpi +ddpi, data = savings)
summary(mod1)
mod2 <- glm(sr ~ pop15 + dpi +ddpi, family=gaussian, data = savings)
summary(mod2)
glm.diag(mod2)
glm.diag.plots(mod2)
prplot(mod2,1)
termplot(mod2, partial.resid=T)
avPlots(mod2)
